from flask import Flask, jsonify, render_template, request, session, redirect, flash, send_file, url_for, make_response
from werkzeug.security import generate_password_hash, check_password_hash
from utils import *
import secrets
import smtplib
import string
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime, timedelta, timezone
import re
import logging
import sys
import traceback
from apscheduler.schedulers.background import BackgroundScheduler
from atualizar_perguntas_dicas import *
import random, string, time
from PIL import Image, ImageEnhance, ImageFilter
from io import BytesIO
import urllib.parse
import qrcode
from functools import wraps

app = Flask(__name__, static_folder='static', template_folder='templates')
# Para fazer depura√ß√£o na render
app.logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('[%(asctime)s] %(levelname)s in %(module)s: %(message)s')
handler.setFormatter(formatter)
app.logger.addHandler(handler)

temas_disponiveis = ["Astronomia", "Biologia", "Esportes", "Geografia", "Hist√≥ria", "M√≠dia"]
app.secret_key = os.getenv("SECRET_KEY")
invite_token = os.getenv("TOKEN_CONVITE")
email_regex = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
dominios_permitidos = {
    "gmail.com", "outlook.com", "hotmail.com", "yahoo.com",
    "protonmail.com", "icloud.com", "live.com"
}
dominios_descartaveis = {
    "mailinator.com", "10minutemail.com", "guerrillamail.com", "tempmail.com"
}
CAPTCHA_BASE_DIR = "static/captcha_imgs"
FUSO_SERVIDOR = timezone(timedelta(hours=-3))
QUESTION_CONFIG = {
    'discursiva': {
        'table': 'perguntas_discursivas',
        'select_cols': [
            'p.id_pergunta',
            'p.subtemas',
            'p.enunciado',
            'p.respostas_corretas',   
            'p.dica',
            'p.nota',
            "COALESCE(f.estrelas, NULL) AS estrelas",
            "r.id_resposta IS NOT NULL AS respondida",
            "p.dificuldade",
            "p.versao"
        ],
        'tipo_str': 'Discursiva'
    },
    'objetiva': {
        'table': 'perguntas_objetivas',
        'select_cols': [
            'p.id_pergunta',
            'p.subtemas',
            'p.enunciado',
            'p.alternativa_a',
            'p.alternativa_b',
            'p.alternativa_c',
            'p.alternativa_d',
            'p.resposta_correta',
            'p.nota',
            "COALESCE(f.estrelas, NULL) AS estrelas",
            "r.id_resposta IS NOT NULL AS respondida",
            "p.dificuldade",
            "p.versao"
        ],
        'tipo_str': 'Objetiva'
    }
}
EMAILS_PROIBIDOS = ['admin@gmail.com']

scheduler = BackgroundScheduler(timezone="America/Sao_Paulo")

# C√≥digo copia e cola gerado pelo Nubank
codigo_pix = os.getenv("QR_CODE")
img = qrcode.make(codigo_pix)
img.save("static/qrcode.png")

def iniciar_agendamento():
    # Analisa 4 vezes por dia se o incremento no n√∫mero de dicas e perguntas dos usu√°rios foi feita
    scheduler.add_job(
    atualizar_perguntas_dicas, 'cron', hour=2, minute=0, id='atualizacao_02h', replace_existing=True
    )
    scheduler.add_job(
    atualizar_perguntas_dicas, 'cron', hour=8, minute=0, id='atualizacao_08h', replace_existing=True
    )
    scheduler.add_job(
    atualizar_perguntas_dicas, 'cron', hour=14, minute=0, id='atualizacao_14h', replace_existing=True
    )
    scheduler.add_job(
    atualizar_perguntas_dicas, 'cron', hour=20, minute=0, id='atualizacao_20h', replace_existing=True
    )
    scheduler.start()

iniciar_agendamento()

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        print("Irei validar token de sess√£o")
        token = None

        # 1Ô∏è‚É£ Tenta extrair do header Authorization
        auth_header = request.headers.get("Authorization")
        if auth_header and auth_header.startswith("Bearer "):
            token = auth_header.split(" ")[1]

        # 2Ô∏è‚É£ Se n√£o tiver no header, tenta pegar do cookie
        if not token:
            token = request.cookies.get("token_sessao")
        if not token:
            return redirect("/login")

        # 3Ô∏è‚É£ Verifica token no banco
        try:
            conn = get_db_connection()
            cur = conn.cursor()
            cur.execute("""
                SELECT id_usuario, ativo
                FROM sessoes 
                WHERE token = %s AND ativo=TRUE AND expira_em > NOW()
            """, (token,))
            row = cur.fetchone()
            print(f"Token √© {token}")
            print(f"Token ativo? {row[1]}")
        except Exception:
            return jsonify({"message": "Erro ao validar sess√£o"}), 500
        finally:
            if cur: cur.close()
            if conn: conn.close()

        if not row:
            return jsonify({"message": "Sess√£o expirada"}), 401

        # Passa o user_id para a rota
        return f(user_id=row[0], *args, **kwargs)

    return decorated

@app.route("/", methods=["GET"])
def index():
    return render_template("login.html")  # ou sua p√°gina inicial real

@app.route("/login", methods=["GET","POST"])
def login():
    conn = cur = None
    try:
        if request.method == "POST":
            if not request.is_json:
                return jsonify(success=False, message="Content-Type deve ser application/json"), 415

            data = request.get_json()
            email = data.get("email")
            senha = data.get("senha")

            if not email or not senha:
                return jsonify(success=False, message="Email e senha s√£o obrigat√≥rios.")
            
            if not re.match(email_regex, email):
                return jsonify(success=False, message="Formato de e-mail inv√°lido"), 400

            conn = get_db_connection()
            cur = conn.cursor()

            # Verifica usu√°rio
            cur.execute("""
                SELECT id_usuario, senha_hash, email_confirmado, nome, dicas_restantes, perguntas_restantes
                FROM usuarios_registrados WHERE email = %s
            """, (email,))
            usuario = cur.fetchone()

            if not usuario:
                return jsonify(success=False, message="E-mail n√£o registrado")

            id_usuario, senha_hash, email_confirmado, nome_usuario, dicas_restantes, perguntas_restantes = usuario
            session["id_usuario"] = id_usuario
            session["email"] = email
            print(f"Id usu√°rio na sess√£o: {session['id_usuario']}")

            if not check_password_hash(senha_hash, senha):
                return jsonify(success=False, message="Senha incorreta")

            if not email_confirmado:
                return jsonify(success=False, message="Voc√™ precisa confirmar seu e-mail antes de fazer login")

            # üîí Invalida sess√µes antigas
            cur.execute("UPDATE sessoes SET ativo = FALSE WHERE id_usuario = %s", (id_usuario,))

            # üîë Cria nova sess√£o/token
            token = secrets.token_urlsafe(64)
            expira_em = datetime.utcnow() + timedelta(hours=6)

            cur.execute("""
                INSERT INTO sessoes (id_usuario, token, expira_em, ativo)
                VALUES (%s, %s, %s, TRUE)
            """, (id_usuario, token, expira_em))

            # Continua sua l√≥gica de ranking/pontua√ß√£o
            cur.execute("SELECT tema FROM pontuacoes_usuarios WHERE id_usuario = %s", (id_usuario,))
            temas_ja_registrados = {row[0].strip().lower() for row in cur.fetchall()}
            temas_normalizados = {tema.strip().lower(): tema for tema in temas_disponiveis}
            temas_faltantes = [nome_original for chave, nome_original in temas_normalizados.items() if chave not in temas_ja_registrados]

            for tema in temas_faltantes:
                cur.execute("INSERT INTO pontuacoes_usuarios (id_usuario, tema, pontuacao) VALUES (%s, %s, %s)", (id_usuario, tema, 0))
            
            cur.execute("SELECT * FROM regras_pontuacao ORDER BY id_ranking")
            linhas = cur.fetchall()
            colunas = [desc[0] for desc in cur.description]
            conn.commit()

            regras_pontuacao = [dict(zip(colunas, linha)) for linha in linhas]

        else:
            return render_template("login.html")

    except Exception:
        if conn: conn.rollback()
        app.logger.error("Erro no login:\n" + traceback.format_exc())
        return jsonify(success=False, message="Erro interno no servidor"), 500
    finally:
        if cur: cur.close()
        if conn: conn.close()

    # üîë Retorna JSON e define cookie HttpOnly
    resp = make_response(jsonify(
        success=True,
        message="Login realizado com sucesso",
        token=token,
        regras_pontuacao=regras_pontuacao,
        dicas_restantes=dicas_restantes,
        perguntas_restantes=perguntas_restantes,
        nome_usuario=nome_usuario
    ), 200)

    # Cookie HttpOnly, expirando junto com o token
    resp.set_cookie(
        "token_sessao",
        token,
        httponly=True,
        secure=False,       # mudar para True se usar HTTPS
        samesite="Lax",
        max_age=6*3600      # 6 horas em segundos
    )

    return resp

def checar_dados_registro(nome, email, senha):
    if not nome or not email or not senha:
        return False, "Preencha todos os campos"

    if not re.match(email_regex, email):
        return False, "E-mail inv√°lido"

    dominio = email.split("@")[-1].lower()

    if dominio in dominios_descartaveis:
        return False, "Dom√≠nio de e-mail tempor√°rio n√£o √© permitido"

    if dominio not in dominios_permitidos:
        return False, "O provedor de e-mail fornecido n√£o √© confi√°vel"

    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("SELECT id_usuario FROM usuarios_registrados WHERE email = %s", (email,))
    if cur.fetchone():
        cur.close()
        conn.close()
        return False, "E-mail j√° registrado"
    cur.close()
    conn.close()

    return True, "Valida√ß√£o OK"

@app.route("/register_validate", methods=["POST"])
def validar_registro():
    data = request.get_json()
    ok, msg = checar_dados_registro(data.get("nome"), data.get("email"), data.get("senha"))
    if not ok:
        return jsonify(success=False, message=msg)

    return jsonify(success=True, message="Valida√ß√£o OK")

@app.route("/register", methods=["POST"])
def registrar():
    data = request.get_json()
    nome = data.get("nome")
    email = data.get("email")
    senha = data.get("senha")
    captcha_token = data.get("captcha_token")
    captcha_selecoes = list(map(int, data.get("captcha_selecoes", [])))

    if email in EMAILS_PROIBIDOS:
        return jsonify(success=False, message="E-mail inv√°lido")

    # Valida√ß√£o do CAPTCHA
    if not captcha_token:
        return jsonify(success=False, message="CAPTCHA token ausente"), 400

    dados_captcha = session.get(f"captcha_{captcha_token}")
    if not dados_captcha or time.time() > dados_captcha.get("expira", 0):
        return jsonify(success=False, message="CAPTCHA expirado ou inv√°lido")

    if sorted(captcha_selecoes) != sorted(dados_captcha.get("corretos", [])):
        return jsonify(success=False, message="Sele√ß√µes do CAPTCHA incorretas")

    # Invalida o CAPTCHA para evitar reutiliza√ß√£o
    session.pop(f"captcha_{captcha_token}", None)

    # Gerar hash da senha e token de confirma√ß√£o
    senha_hash = generate_password_hash(senha)
    token = gerar_token_confirmacao()
    expiracao = datetime.utcnow() + timedelta(hours=24)

    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO usuarios_registrados (
            nome, email, senha_hash, email_confirmado,
            token_confirmacao, expiracao_token_confirmacao
        )
        VALUES (%s, %s, %s, FALSE, %s, %s)
    """, (nome, email, senha_hash, token, expiracao))
    conn.commit()
    cur.close()
    conn.close()

    link_confirmacao = f"{base_url}/confirmar_email?token={token}"
    enviar_email_confirmacao(email, nome, link_confirmacao)

    return jsonify(success=True, message="Registro realizado! Verifique seu e-mail para confirmar")

def carregar_e_transformar(caminho_img):
    """Carrega a imagem do CAPTCHA com alguns ajustes para evitar identifica√ß√£o autom√°tica"""
    img = Image.open(caminho_img).convert("RGB")
    # Ajuste de brilho/contraste
    enhancer = ImageEnhance.Contrast(img)
    img = enhancer.enhance(random.uniform(0.85, 1.15))
    # Pequeno desfoque
    img = img.filter(ImageFilter.GaussianBlur(random.uniform(0, 1)))
    # Opcional: redimensiona para um tamanho consistente (ex: 200x200) mantendo a propor√ß√£o
    img.thumbnail((240, 240), Image.LANCZOS)
    # Salvar em mem√≥ria
    buffer = BytesIO()
    img.save(buffer, format="JPEG", quality=85)
    buffer.seek(0)
    return buffer

@app.route("/captcha_novo")
def captcha_novo():
    # Lista de categorias (pastas) dentro de CAPTCHA_BASE_DIR
    categorias = [d for d in os.listdir(CAPTCHA_BASE_DIR) if os.path.isdir(os.path.join(CAPTCHA_BASE_DIR, d))]
    if not categorias:
        return jsonify({"error": "Sem categorias de CAPTCHA configuradas"}), 500
    
    categoria_correta = random.choice(categorias)

    # 3 imagens corretas
    todas_da_cat = os.listdir(os.path.join(CAPTCHA_BASE_DIR, categoria_correta))
    if len(todas_da_cat) < 3:
        return jsonify({"error": "Categoria sem imagens suficientes"}), 500
    corretas = random.sample(todas_da_cat, 3)
    corretas_paths = [f"{categoria_correta}/{fname}" for fname in corretas]


    # 6 imagens incorretas
    outras_categorias = [c for c in categorias if c != categoria_correta]
    incorretas = []
    while len(incorretas) < 6:
        cat = random.choice(outras_categorias)
        arquivos = os.listdir(os.path.join(CAPTCHA_BASE_DIR, cat))
        if not arquivos:
            continue
        img = random.choice(arquivos)
        caminho = f"{cat}/{img}"
        if caminho not in incorretas:
            incorretas.append(caminho)

    todas = corretas_paths + incorretas
    random.shuffle(todas)

    # Criar token para este CAPTCHA
    token = secrets.token_hex(16)

    # Guardar na sess√£o quais √≠ndices s√£o corretos
    session[f"captcha_{token}"] = {
        "categoria": categoria_correta,
        "corretos": [todas.index(path) for path in corretas_paths],
        "expira": time.time() + 180
    }

    # Gera URLs codificando segmentos
    imagens_urls = []
    for p in todas:
        cat, fname = p.split("/", 1)
        imagens_urls.append(f"/captcha_imagem/{urllib.parse.quote(cat)}/{urllib.parse.quote(fname)}")
    return jsonify({
        "token": token,
        "categoria": categoria_correta,
        "imagens": imagens_urls
    })

@app.route("/captcha_imagem/<categoria>/<filename>")
def captcha_imagem(categoria, filename):
    # Decodifica j√° feita pelo Flask ‚Äî junta os segmentos
    subpath = os.path.join(categoria, filename)
    safe_subpath = os.path.normpath(subpath).lstrip(os.sep)
    full_path = os.path.join(CAPTCHA_BASE_DIR, safe_subpath)

    base_real = os.path.realpath(CAPTCHA_BASE_DIR)
    target_real = os.path.realpath(full_path)
    if not target_real.startswith(base_real):
        return "Caminho inv√°lido", 400
    if not os.path.isfile(target_real):
        return "Imagem n√£o encontrada", 404

    buffer = carregar_e_transformar(target_real)
    # evita cache no cliente (opcional)
    resp = send_file(buffer, mimetype="image/jpeg")
    resp.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, max-age=0'
    return resp

def formatar_hora_servidor(timestamp):
    """Retorna data/hora formatada no fuso do servidor."""
    if not timestamp:
        return None
    dt = datetime.fromtimestamp(timestamp, FUSO_SERVIDOR)
    offset = FUSO_SERVIDOR.utcoffset(None)
    return dt.strftime("%H:%M")

@app.route('/verificar_bloqueio')
def verificar_bloqueio():
    info = session.get('bloqueio_captcha', {'tentativas_registro': 0, 'bloqueado_ate': 0})
    agora = time.time()

    if info.get('bloqueado_ate', 0) > agora:
        return jsonify(
            bloqueado=True,
            tentativas_registro=info['tentativas_registro'],
            bloqueado_ate=info['bloqueado_ate'],
            bloqueado_ate_str=formatar_hora_servidor(info['bloqueado_ate'])
        )
    else:
        session.pop('bloqueio_captcha', None)
        return jsonify(bloqueado=False)

@app.route('/registrar_falha_captcha', methods=['POST'])
def registra_falha_sessao():
    agora = time.time()
    info = session.get('bloqueio_captcha', {'tentativas_registro': 0, 'bloqueado_ate': 0})
    info['tentativas_registro'] += 1

    print(f"Tentativas: {info['tentativas_registro']}")
    if info['tentativas_registro'] >= 6:
        info['bloqueado_ate'] = agora + 15 * 60  # bloqueio 15 minutos

    session['bloqueio_captcha'] = info

    return jsonify(
        success=True,
        tentativas_registro=info['tentativas_registro'],
        bloqueado_ate=info['bloqueado_ate'],
        bloqueado_ate_str=formatar_hora_servidor(info['bloqueado_ate'])
    )

@app.route('/confirmar_email')
def confirmar_email():
    token = request.args.get('token')

    if not token:
        return render_template('mensagem.html', titulo="Erro", mensagem="Token de confirma√ß√£o ausente.")

    conn = get_db_connection()
    cur = conn.cursor()

    try:
        # Busca usu√°rio com o token fornecido e ainda v√°lido
        cur.execute("""
            SELECT id_usuario, expiracao_token_confirmacao 
            FROM usuarios_registrados 
            WHERE token_confirmacao = %s
        """, (token,))
        usuario = cur.fetchone()

        if not usuario:
            return render_template('mensagem.html', titulo="Erro", mensagem="Token inv√°lido.")

        id_usuario, expiracao = usuario

        if not expiracao or expiracao < datetime.utcnow():
            return render_template('mensagem.html', titulo="Token expirado", mensagem="O token de confirma√ß√£o expirou.")

        # Atualiza o status do e-mail como confirmado
        cur.execute("""
            UPDATE usuarios_registrados
            SET email_confirmado = TRUE,
                token_confirmacao = NULL,
                expiracao_token_confirmacao = NULL
            WHERE id_usuario = %s
        """, (id_usuario,))
        conn.commit()

        return render_template('mensagem.html', titulo="Sucesso", mensagem="E-mail confirmado com sucesso! Agora voc√™ pode fazer login.")
    
    except Exception:
        if conn:
            conn.rollback()
        return render_template('mensagem.html', titulo="Erro", mensagem="Erro ao confirmar o e-mail. Tente novamente mais tarde.")
    
    finally:
        if cur: cur.close()
        if conn: conn.close()

def gerar_token_confirmacao(tamanho=32):
    alfabeto = string.ascii_letters + string.digits
    return ''.join(secrets.choice(alfabeto) for _ in range(tamanho))

def enviar_email_confirmacao(email_destinatario, nome_destinatario, link_confirmacao):
    remetente = email_remetente
    senha = senha_app
    porta = int(porta_email)

    assunto = "Confirma√ß√£o de cadastro - Desafio das Perguntas"
    corpo = f"""
    Ol√°, {nome_destinatario}!

    Clique no link abaixo para confirmar seu cadastro:

    {link_confirmacao}

    O link expira em 24 horas.

    """

    msg = MIMEMultipart()
    msg['From'] = remetente
    msg['To'] = email_destinatario
    msg['Subject'] = assunto
    msg.attach(MIMEText(corpo, 'plain'))

    try:
        with smtplib.SMTP("smtp.gmail.com", porta) as servidor:
            servidor.starttls()
            servidor.login(remetente, senha)
            servidor.send_message(msg)
        return True
    except Exception:
        return False

@app.route("/home")
def home():
    return render_template("home.html")

@app.route("/doa√ß√µes")
@token_required
def doacoes(user_id):
    chave_pix = os.getenv("CHAVE_PIX")
    return render_template("doacoes.html", chave_pix=chave_pix)

@app.route("/checkout/<metodo>/<int:plano_id>")
def checkout(metodo, plano_id):
    conn = cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("SELECT plano, preco FROM regras_plano WHERE id = %s", (plano_id,))
        plano = cur.fetchone()
        if not plano:
            return "Plano n√£o encontrado", 404
        
        plano_nome, preco = plano

        if metodo == "cartao":
            checkout_url = f"https://provedor.com/checkout?plano={plano_id}&metodo=cartao"
            checkout_url = f"https://www.mercadopago.com.br/developers/pt/guides/checkout"
        elif metodo == "pix":
            checkout_url = f"https://provedor.com/checkout?plano={plano_id}&metodo=pix"
            checkout_url = f"https://dev.pagseguro.uol.com.br/docs/checkout"
        elif metodo == "boleto":
            checkout_url = f"https://provedor.com/checkout?plano={plano_id}&metodo=boleto"
            checkout_url = f"https://docs.pagar.me/"
        else:
            return "M√©todo de pagamento inv√°lido", 400

        return redirect(checkout_url)

    except Exception:
        app.logger.exception("Erro ao iniciar checkout:")
        return "Erro interno", 500
    finally:
        if cur: cur.close()
        if conn: conn.close()

@app.route("/recupera√ß√£o-de-senha", methods=["POST"])
def esqueci_senha():
    data = request.get_json()
    email = data.get("email", "").strip()

    # mensagem padr√£o
    mensagem_padrao = "Se o e-mail estiver cadastrado, enviaremos instru√ß√µes."

    if not email:
        return jsonify(success=False, message="Informe um e-mail v√°lido.")

    # Busca email do usu√°rio no banco
    conn = cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()

        cur.execute("SELECT id_usuario, nome FROM usuarios_registrados WHERE email = %s", (email,))
        usuario = cur.fetchone()
    
        if usuario:
            token = secrets.token_urlsafe(32)
            expira = datetime.utcnow() + timedelta(hours=1)

            cur.execute("""
                UPDATE usuarios_registrados
                SET token_recuperacao = %s, expiracao_token_recuperacao = %s
                WHERE id_usuario = %s
            """, (token, expira, usuario[0]))
            conn.commit()
            
            # construir link de recupera√ß√£o
            link_recuperacao = url_for('reset_senha', token=token, _external=True)

            # montar mensagem
            conteudo_email = f"""
            Ol√° {usuario[1]},

            Recebemos uma solicita√ß√£o para redefinir sua senha.
            Clique no link abaixo para criar uma nova senha:

            {link_recuperacao}

            Se voc√™ n√£o solicitou a recupera√ß√£o de senha, ignore esta mensagem.
            """

            # enviar email
            try:
                enviar_email_recuperacao(email, "Recupera√ß√£o de Senha - Desafio das Perguntas", conteudo_email)
            except Exception as e:
                print("Erro ao enviar email:", e)
                return jsonify(success=False, message=mensagem_padrao)
    except Exception:
        if conn:
            conn.rollback()
        app.logger.exception(f"Erro na recupera√ß√£o de senha")
    finally:
        if cur: cur.close()
        if conn: conn.close()

    # Retorna mensagem padr√£o sempre, mesmo que o e-mail n√£o exista
    return jsonify(success=True, message=mensagem_padrao)

def enviar_email_recuperacao(destinatario, assunto, conteudo):

    remetente = email_remetente
    senha = senha_app

    msg = MIMEMultipart()
    msg['From'] = remetente
    msg['To'] = destinatario
    msg['Subject'] = assunto

    msg.attach(MIMEText(conteudo, 'plain'))

    with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
        server.login(remetente, senha)
        server.send_message(msg)

@app.route("/pergunta/<int:id_pergunta>/<tipo_pergunta>/gabarito", methods=["GET"])
@token_required
def get_gabarito(id_pergunta, tipo_pergunta, user_id):
    """Fun√ß√£o para s√≥ pegar o gabarito e nota da pergunta ap√≥s resposta enviada pelo usu√°rio no modo desafio (evita expor o gabarito no localStorage)"""
    conn = cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()

        # Consulta para objetivas
        if tipo_pergunta == 'objetiva':
            cur.execute("""
                SELECT resposta_correta, nota
                FROM perguntas_objetivas
                WHERE id_pergunta = %s
            """, (id_pergunta,))
            row = cur.fetchone()

            if not row:
                return {"erro": "Pergunta n√£o encontrada"}, 404
            resposta_correta, nota = row

            return {
                "resposta_correta": resposta_correta,
                "nota": nota
            }
        # Consulta para discursivas
        else:
            cur.execute("""
                SELECT respostas_corretas, nota
                FROM perguntas_discursivas
                WHERE id_pergunta = %s
            """, (id_pergunta,))
            row = cur.fetchone()

            if not row:
                return {"erro": "Pergunta n√£o encontrada"}, 404
            rc, nota = row

            # Fun√ß√£o abaixo repetida em listar_perguntas
            try:
                respostas_corretas = [r.strip() if isinstance(r, str) else r for r in rc]
            except Exception:
                respostas_corretas = list(rc)

            return {
                "respostas_corretas": respostas_corretas,
                "nota": nota
            }
    except Exception:
        app.logger.exception("Erro ao buscar gabarito")
        return {"erro": "Erro interno"}, 500
    finally:
        if cur: cur.close()
        if conn: conn.close()

@app.route('/api/perguntas', methods=['GET'])
@token_required
def listar_perguntas(user_id):
    """
    Retorna perguntas agrupadas por dificuldade conforme tipo (discursiva/objetiva) e modo (desafio/revisao).
    Retorna tamb√©m as pontua√ß√µes atuais do usu√°rio em cada tema.
    """
    # par√¢metros de query
    tema = request.args.get('tema')
    modo = (request.args.get('modo') or '').lower()
    tipo_pergunta = (request.args.get('tipo-de-pergunta') or '').lower()
    id_usuario = session.get('id_usuario')
    print(f"2.ID do usu√°rio: {id_usuario}")

    # Configura√ß√µes locais
    limit = 90
    privileged_ids = (4, 6, 16)  # ids com permiss√£o para ver perguntas inativas

    # Valida√ß√µes
    if not tema or modo not in ('desafio', 'revisao') or tipo_pergunta not in ('objetiva', 'discursiva'):
        print("Par√¢metros inv√°lidos ou ausentes")
        return jsonify({'erro': 'Par√¢metros inv√°lidos ou ausentes'}), 400
    if not id_usuario:
        print("Usu√°rio n√£o autenticado")
        return jsonify({'erro': 'Usu√°rio n√£o autenticado'}), 401
    
    cfg = QUESTION_CONFIG.get(tipo_pergunta)
    if not cfg:
        print("Tipo de pergunta inv√°lido")
        return jsonify({'erro': 'Tipo de pergunta inv√°lido'}), 400
    
    # Conex√£o com servidor
    conn = cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor(cursor_factory=RealDictCursor)
    except Exception:
        print("Erro ao tentar conectar para buscar perguntas")
        app.logger.exception("Erro ao tentar conectar para buscar perguntas para o usu√°rio com id %s", id_usuario)
        return jsonify({'erro': 'Erro ao tentar conectar para buscar novas perguntas'}), 500

    # Busca das perguntas
    try:
        is_privileged = int(id_usuario) in privileged_ids

        select_clause = ",\n".join(cfg['select_cols'])
        tipo_str = cfg['tipo_str']   # Usado para filtrar feedbacks/respostas
        table = cfg['table']         # Nome da tabela ‚Äî vindo do cfg interno (seguro)

        
        where_status = "p.status != 'Deletada'" if is_privileged else "p.status = 'Ativa'"
        
        """
        where_status = "p.status = 'Em teste'" if is_privileged else "p.status = 'Ativa'"
        """
        
        sql = f"""
            SELECT {select_clause}
            FROM {table} p
            LEFT JOIN respostas_usuarios r
                ON p.id_pergunta = r.id_pergunta AND r.id_usuario = %s AND r.tipo_pergunta = %s
            LEFT JOIN feedbacks f
                ON p.id_pergunta = f.id_pergunta AND f.id_usuario = %s AND f.tipo_pergunta = %s
            WHERE p.tema = %s AND {where_status}
            LIMIT %s
        """

        params = (id_usuario, tipo_str, id_usuario, tipo_str, tema, limit)
        cur.execute(sql, params)
        linhas = cur.fetchall()

        perguntas_por_dificuldade = {'F√°cil': [], 'M√©dio': [], 'Dif√≠cil': []}

        for row in linhas:
            dificuldade = row.get('dificuldade') or 'M√©dio'  # Se por algum motivo for nulo, evita KeyError
            respondida = bool(row.get('respondida'))

            sb = row.get('subtemas') or []
            try:
                subtemas = [s.strip() if isinstance(s, str) else s for s in sb]
            except Exception:
                app.logger.exception("Erro ao tentar listar subtemas do usu√°rio com id %s para a pergunta com id %s", id_usuario, row['id_pergunta'])
                subtemas = list(sb)

            if tipo_pergunta == 'discursiva':
                rc = row.get('respostas_corretas') or []
                try:
                    respostas_corretas = [r.strip() if isinstance(r, str) else r for r in rc]
                except Exception:
                    respostas_corretas = list(rc)

                item = {
                    'id_pergunta': row['id_pergunta'],
                    'enunciado': row['enunciado'],
                    'dica': row.get('dica'),
                    'dificuldade': dificuldade,
                    'versao_pergunta': row.get('versao'),
                    'estrelas': row.get('estrelas'),
                }

                # Campos extras s√≥ no modo revis√£o
                if modo == 'revisao':
                    item.update({
                        'subtemas': subtemas,
                        'respostas_corretas': respostas_corretas,
                        'nota': row.get('nota'),
                    })

            else:  # objetiva
                item = {
                    'id_pergunta': row['id_pergunta'],
                    'enunciado': row['enunciado'],
                    'alternativa_a': row.get('alternativa_a'),
                    'alternativa_b': row.get('alternativa_b'),
                    'alternativa_c': row.get('alternativa_c'),
                    'alternativa_d': row.get('alternativa_d'),
                    'dificuldade': dificuldade,
                    'versao_pergunta': row.get('versao'),
                    'estrelas': row.get('estrelas'),
                }

                # No modo revis√£o pode mandar resposta correta e nota
                if modo == 'revisao':
                    item.update({
                        'resposta_correta': row.get('resposta_correta'),
                        'nota': row.get('nota'),
                        'subtemas': subtemas,
                    })
            # filtra por modo
            if modo == 'desafio' and not respondida:
                perguntas_por_dificuldade.setdefault(dificuldade, []).append(item)
            elif modo == 'revisao' and respondida:
                perguntas_por_dificuldade.setdefault(dificuldade, []).append(item)
    except Exception:
        print(f"Erro ao buscar perguntas para o usu√°rio")
        app.logger.exception("Erro ao buscar perguntas para o usu√°rio com id %s", id_usuario)
        return jsonify({'erro': 'Erro interno ao consultar perguntas'}), 500
    finally:
        if cur: cur.close()
        if conn: conn.close()

    pontuacoes_usuario = buscar_pontuacoes_usuario(id_usuario)

    return jsonify({
        'perguntas': perguntas_por_dificuldade,
        'pontuacoes_usuario': pontuacoes_usuario
    })

@app.route("/reset_senha", methods=["GET", "POST"])
def reset_senha():
    token = request.args.get("token") if request.method == "GET" else request.form.get("token")
    if not token:
        return render_template("mensagem.html", titulo="Erro", mensagem="Token ausente.")

    conn = cur = None
    try:
        conn = get_db_connection()
        cur = conn.cursor()

        # Busca usu√°rio com token v√°lido
        cur.execute("""
            SELECT id_usuario, expiracao_token_recuperacao
            FROM usuarios_registrados
            WHERE token_recuperacao = %s
        """, (token,))
        usuario = cur.fetchone()

        if not usuario:
            return render_template("mensagem.html", titulo="Erro", mensagem="Token inv√°lido.")

        id_usuario, expira = usuario

        if not expira or expira < datetime.utcnow():
            return render_template("mensagem.html", titulo="Token expirado", mensagem="O token de recupera√ß√£o expirou.")
        
        if request.method == "POST":
            # Recebe novas senhas
            nova_senha = request.form.get("senha", "").strip()
            confirmar_senha = request.form.get("confirmar_senha", "").strip()

            if not nova_senha or not confirmar_senha:
                return render_template("reset_senha.html", token=token, erro="Preencha ambos os campos.")
            if nova_senha != confirmar_senha:
                return render_template("reset_senha.html", token=token, erro="As senhas n√£o coincidem.")

            # Hash da nova senha
            senha_hash = generate_password_hash(nova_senha)

            # Atualiza senha e remove token
            cur.execute("""
                UPDATE usuarios_registrados
                SET senha_hash = %s,
                    token_recuperacao = NULL,
                    expiracao_token_recuperacao = NULL
                WHERE id_usuario = %s
            """, (senha_hash, id_usuario))
            conn.commit()

            return render_template("mensagem.html", titulo="Sucesso", mensagem="Senha redefinida com sucesso! Agora voc√™ pode fazer login.")

        # GET: exibe formul√°rio
        return render_template("reset_senha.html", token=token)

    except Exception:
        if conn:
            conn.rollback()
        app.logger.exception(f"Erro reset_senha:")
        return render_template("mensagem.html", titulo="Erro", mensagem="Erro ao redefinir a senha. Tente novamente.")
    finally:
        if cur: cur.close()
        if conn: conn.close()

@app.route("/politica-de-privacidade")
def politica_privacidade():
    return render_template("privacy_policy.html")

@app.route("/sobre-o-app")
def sobre_app():
    return render_template("sobre_o_app.html")

@app.route("/termos-de-uso")
def termos_uso():
    return render_template("termos_de_uso.html")

@app.route("/quiz")
@token_required
def quiz(user_id):
    tema = request.args.get("tema", "Geral")
    nivel = request.args.get("nivel", "M√©dio")
    return render_template("quiz.html", tema=tema, nivel=nivel)

@app.route("/usar_dica", methods=["GET","POST"])
@token_required
def usar_dica(user_id):
    if "id_usuario" not in session:
        return jsonify(success=False, message="Usu√°rio n√£o autenticado."), 401

    id_usuario = session["id_usuario"]

    conn = get_db_connection()
    cur = conn.cursor()

    # Verifica se ainda tem dicas
    cur.execute("SELECT dicas_restantes FROM usuarios_registrados WHERE id_usuario = %s", (id_usuario,))
    row = cur.fetchone()

    if not row or row[0] <= 0:
        cur.close()
        conn.close()
        return jsonify(success=False, message="Voc√™ n√£o possui mais dicas."), 400

    novas_dicas = row[0] - 1
    cur.execute(
        "UPDATE usuarios_registrados SET dicas_restantes = %s WHERE id_usuario = %s",
        (novas_dicas, id_usuario)
    )

    conn.commit()
    cur.close()
    conn.close()

    return jsonify(success=True, dicas_restantes=novas_dicas)

@app.route("/enviar_feedback", methods=["POST"])
@token_required
def enviar_feedback(user_id):
    data = request.get_json()
    id_pergunta = data.get("id_pergunta")
    tipo_pergunta = data.get("tipo_pergunta").capitalize()
    email_usuario = session.get("email")
    estrelas = data.get("estrelas")
    versao_pergunta = data.get("versao_pergunta")
    id_usuario = session.get("id_usuario")

    if not all([id_pergunta, tipo_pergunta, email_usuario, estrelas, versao_pergunta, id_usuario]):
        return jsonify({"erro": "Dados incompletos"}), 400
    
    try:
        conn = get_db_connection()
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO feedbacks (id_pergunta, tipo_pergunta, email_usuario, estrelas, versao_pergunta, id_usuario)
            VALUES (%s, %s, %s, %s, %s, %s)
            ON CONFLICT (id_pergunta, tipo_pergunta, id_usuario)
            DO UPDATE SET estrelas = EXCLUDED.estrelas, versao_pergunta = EXCLUDED.versao_pergunta, ultima_atualizacao = date_trunc('second', date_trunc('second', CURRENT_TIMESTAMP AT TIME ZONE 'America/Sao_Paulo'));
        """, (id_pergunta, tipo_pergunta, email_usuario, estrelas, versao_pergunta, id_usuario))
        conn.commit()
        cur.close()
        return jsonify({"sucesso": True})
    except Exception as e:
        if conn:
            conn.rollback()
        return jsonify({"erro": str(e)}), 500

def buscar_pontuacoes_usuario(id_usuario):
    """Busca pontua√ß√µes do usu√°rio em cada tema de perguntas"""
    pontuacoes_usuario = {}
    conn = cur = None

    # Conex√£o com o servidor
    try:
        conn = get_db_connection()
        cur = conn.cursor()
    except Exception as e:
        app.logger.exception("Erro ao tentar conectar para buscar pontua√ß√µes do usu√°rio com id %s: %s", id_usuario, e)
        return pontuacoes_usuario
    
    # Busca das pontua√ß√µes do usu√°rio
    try:
        cur.execute(
            "SELECT tema, pontuacao FROM pontuacoes_usuarios WHERE id_usuario = %s",
            (id_usuario,)
        )
        pontuacoes_usuario = {tema: pontuacao for tema, pontuacao in cur.fetchall()}
        print(f"Pontua√ß√µes do usu√°rio recebidas: {pontuacoes_usuario}")
    except Exception as e:
        app.logger.exception("Erro ao tentar obter pontua√ß√µes do usu√°rio %s", id_usuario)
    finally:
        if cur: cur.close()
        if conn: conn.close()

    return pontuacoes_usuario

@app.route("/registrar_resposta", methods=["POST"])
@token_required
def registrar_resposta(user_id):
    dados = request.get_json()
    dados["tipo_pergunta"] = dados["tipo_pergunta"].capitalize()
    id_usuario = session.get("id_usuario")
    if not id_usuario:
        return jsonify({"sucesso": False, "mensagem": "Usu√°rio n√£o autenticado"})
    conn = cur = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cur:
            # Registra a resposta do usu√°rio
            cur.execute("""
                INSERT INTO respostas_usuarios (
                    id_usuario, id_pergunta, tipo_pergunta, versao_pergunta, resposta_usuario,
                    acertou, usou_dica, pontos_ganhos, tempo_gasto
                )
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                id_usuario,
                dados["id_pergunta"],
                dados["tipo_pergunta"],
                dados["versao_pergunta"],
                dados["resposta_usuario"],
                dados["acertou"],
                dados.get("usou_dica", False),
                dados["pontos_ganhos"],
                dados["tempo_gasto"]
            ))
            # Atualiza a pontua√ß√£o do usu√°rio
            cur.execute("""
                INSERT INTO pontuacoes_usuarios (id_usuario, tema, pontuacao)
                VALUES (%s, %s, %s)
                ON CONFLICT (id_usuario, tema)
                DO UPDATE SET pontuacao = pontuacoes_usuarios.pontuacao + EXCLUDED.pontuacao
                RETURNING pontuacao
            """, (id_usuario, dados["tema"], dados["pontos_ganhos"]))
            nova_pontuacao = cur.fetchone()[0]

            # Atualiza a quantidade de perguntas restantes do usu√°rio
            cur.execute("""
                SELECT perguntas_restantes FROM usuarios_registrados WHERE id_usuario = %s
                """, (id_usuario,))
            perguntas_restantes = cur.fetchone()[0]
            nova_perguntas_restantes = max(0, perguntas_restantes - 1)
            cur.execute("""
                UPDATE usuarios_registrados SET perguntas_restantes = %s WHERE id_usuario = %s
            """, (nova_perguntas_restantes, id_usuario))

            conn.commit()
            return jsonify({"sucesso": True, "nova_pontuacao": nova_pontuacao, "perguntas_restantes": nova_perguntas_restantes})

    except Exception:
        if conn:
            conn.rollback()
        app.logger.exception("Erro ao tentar registrar pergunta com id %s perguntas para o usu√°rio com id %s", dados["id_pergunta"], id_usuario)
    finally:
        if cur: cur.close()
        if conn: conn.close()

if not database_url:
    if __name__ == '__main__':
        app.run(debug=True)
